---
import { fetchPosts as fetchMatchOne } from '../lib/matchone.js';
import { fetchPosts as fetchMatchTwo } from '../lib/matchtwo.js';
import { lastBuildTime } from '../lib/buildInfo.js';
import '../styles/global.css';

const matchOnePosts = await fetchMatchOne();
const matchTwoPosts = await fetchMatchTwo();
const base = import.meta.env.BASE_URL || "/";
const canonicalURL = new URL(Astro.url.pathname, Astro.site);
---

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="shortcut icon" href={`${base}/favicon.ico`} type="image/x-icon">
  <link href={`${base}/192.png`} rel="icon" sizes="192x192" type="image/png">
  <link href={`${base}/180.png`} rel="apple-touch-icon">
  <title>üèè Free Live Cricket Score Updates</title>
  <meta name="description" content="üèè Latest live cricket score and Match updates ü•é.">
  <link rel="canonical" href={`${canonicalURL}/`} />
  <meta name="generator" content={Astro.generator} />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Rubik:ital,wght@0,300..900;1,300..900&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
</head>
<body>

<header class="app-header">
    <div class="app-title">
      <span class="material-icons">sports_cricket</span>
    </div>
    <div class="header-actions">
      <button class="refresh-btn" id="refresh-btn" title="Refresh scores">
        <span class="material-icons">refresh</span>
      </button>
    </div>
  </header>

  <div class="app-content">
    <div id="score-one" class="page active">
      {matchOnePosts.length > 0 ? (
        matchOnePosts.map((post) => {
          const contentParts = post.content.split('<br><br>');
          const matchStatus = contentParts[0] || "Match status unavailable";
          const currentScore = contentParts[1] || "No live score available";
          const runRate = contentParts[2] || "Run rate: N/A";
          const batsmen = contentParts[3] || "No batting data available";
          const bowler = contentParts[4] || "No bowling data available";

          return (
            <div class="card">
              <div class="card-header">{post.title}</div>
              <div class="card-content">
                <div class="score-card">
                  <div class="score-title">Match Status</div>
                  <div class="score-value">{matchStatus}</div>
                </div>
                
                {currentScore !== "No live score available" && (
                  <div class="score-card">
                    <div class="score-title">Current Score</div>
                    <div class="score-value">{currentScore}</div>
                    <div class="score-detail">{runRate}</div>
                  </div>
                )}
                
                {!batsmen.includes("No data") && (
                  <div class="score-card">
                    <div class="score-title">Batting</div>
                    <div class="score-detail">{batsmen}</div>
                  </div>
                )}
                
                {!bowler.includes("No data") && (
                  <div class="score-card">
                    <div class="score-title">Bowling</div>
                    <div class="score-detail">{bowler}</div>
                  </div>
                )}
              </div>
            </div>
          );
        })
      ) : (
        <div class="card">
          <div class="card-content">
            <div class="score-card">
              <div class="score-title">Match Status</div>
              <div class="score-value">No match data available</div>
              <div class="score-detail">Please check back later</div>
            </div>
          </div>
        </div>
      )}
    </div>

    <div id="score-two" class="page">
      {matchTwoPosts.length > 0 ? (
        matchTwoPosts.map((post) => {
          const contentParts = post.content.split('<br><br>');
          const matchStatus = contentParts[0] || "Match status unavailable";
          const currentScore = contentParts[1] || "No live score available";
          const runRate = contentParts[2] || "Run rate: N/A";
          const batsmen = contentParts[3] || "No batting data available";
          const bowler = contentParts[4] || "No bowling data available";

          return (
            <div class="card">
              <div class="card-header">{post.title}</div>
              <div class="card-content">
                <div class="score-card">
                  <div class="score-title">Match Status</div>
                  <div class="score-value">{matchStatus}</div>
                </div>
                
                {currentScore !== "No live score available" && (
                  <div class="score-card">
                    <div class="score-title">Current Score</div>
                    <div class="score-value">{currentScore}</div>
                    <div class="score-detail">{runRate}</div>
                  </div>
                )}
                
                {!batsmen.includes("No data") && (
                  <div class="score-card">
                    <div class="score-title">Batting</div>
                    <div class="score-detail">{batsmen}</div>
                  </div>
                )}
                
                {!bowler.includes("No data") && (
                  <div class="score-card">
                    <div class="score-title">Bowling</div>
                    <div class="score-detail">{bowler}</div>
                  </div>
                )}
              </div>
            </div>
          );
        })
      ) : (
        <div class="card">
          <div class="card-content">
            <div class="score-card">
              <div class="score-title">Match Status</div>
              <div class="score-value">No match data available</div>
              <div class="score-detail">Please check back later</div>
            </div>
          </div>
        </div>
      )}
    </div>

    <div id="settings" class="page">
      <div class="card">
        <div class="card-header">Settings</div>
        <div class="settings-container">
          <div class="setting-item">
            <span>Dark Mode</span>
            <label class="switch">
              <input type="checkbox" id="dark-mode-toggle">
              <span class="slider"></span>
            </label>
          </div>
          <div class="setting-item">
            <span>Built Using:</span>
            <span>{Astro.generator}</span>
          </div>
          <div class="setting-item">
            <span>App Version:</span>
            <span>0.0.2</span>
          </div>
          <div class="setting-item">
            <span>Last Updated:</span>
            <span>{lastBuildTime}</span>
          </div>
          <div class="setting-item">
            <span>API Rate Limit:</span>
            <span id="rate-limit-info">1 request per minute</span>
          </div>
          <div class="setting-item">
            <span>Next API Request:</span>
            <span id="next-request-time">Ready</span>
          </div>
          <div class="badge-container">
            <h2 class="badge-title">GitHub Actions Deployment Status</h2>
            <div class="github-badge">
              <a href="https://github.com/mskian/cricket/actions/workflows/deploy.yml" target="_blank" rel="nofollow noopener">
                <img src="https://github.com/mskian/cricket/actions/workflows/deploy.yml/badge.svg" 
                     alt="Deploy Website to GitHub Pages">
              </a>
            </div>
            <p class="badge-description">
              This badge shows the status of our automatic deployment workflow to GitHub Pages. 
              Click on the badge to view the latest workflow runs and deployment status.
            </p>
          </div>
        </div>
      </div>
    </div>
  </div>

  <nav class="bottom-nav">
    <a href="#" class="nav-item active" data-page="score-one">
      <span class="material-icons">home</span>
      <span class="nav-label">Match 1</span>
    </a>
    <a href="#" class="nav-item" data-page="score-two">
      <span class="material-icons">sports</span>
      <span class="nav-label">Match 2</span>
    </a>
    <a href="#" class="nav-item" data-page="settings">
      <span class="material-icons">settings</span>
      <span class="nav-label">Settings</span>
    </a>
  </nav>

<script>
    const refreshBtn = document.getElementById('refresh-btn');
    const darkModeToggle = document.getElementById('dark-mode-toggle');
    const nextRequestTimeEl = document.getElementById('next-request-time');
    
    const apiConfig = {
      baseUrl: 'https://sanproxy.vercel.app/trigger',
      rateLimit: {
        maxRequests: 1,
        timeWindow: 60000,
        cooldownPeriod: 120000,
        errorCooldown: 300000
      },
      retry: {
        maxRetries: 2,
        delay: 2000
      },
      updateInterval: 1000
    };

    const appState = {
      rateLimit: {
        remaining: apiConfig.rateLimit.maxRequests,
        resetTime: 0,
        lastRequest: 0
      },
      retryCount: 0,
      isDarkMode: localStorage.getItem('theme') === 'dark' || 
                 (!localStorage.getItem('theme') && window.matchMedia('(prefers-color-scheme: dark)').matches),
      countdownInterval: null
    };

    function initializeUI() {
      if (appState.isDarkMode) {
        document.documentElement.setAttribute('data-theme', 'dark');
        darkModeToggle.checked = true;
      }
      
      document.querySelectorAll('.nav-item').forEach(item => {
        item.addEventListener('click', function(e) {
          e.preventDefault();
          document.querySelectorAll('.nav-item').forEach(nav => nav.classList.remove('active'));
          document.querySelectorAll('.page').forEach(page => page.classList.remove('active'));
          this.classList.add('active');
          document.getElementById(this.getAttribute('data-page')).classList.add('active');
        });
      });
      
      darkModeToggle.addEventListener('change', function() {
        appState.isDarkMode = this.checked;
        if (this.checked) {
          document.documentElement.setAttribute('data-theme', 'dark');
          localStorage.setItem('theme', 'dark');
        } else {
          document.documentElement.removeAttribute('data-theme');
          localStorage.setItem('theme', 'light');
        }
      });
      
      const savedState = localStorage.getItem('rateLimitState');
      if (savedState) {
        try {
          const parsed = JSON.parse(savedState);
          if (parsed.resetTime > Date.now()) {
            appState.rateLimit = parsed;
            startCountdown();
          }
        } catch (e) {
          console.error('Failed to parse rate limit state', e);
        }
      }
      
      refreshBtn.addEventListener('click', triggerUpdate);
      updateRateLimitDisplay();
    }

    function startCountdown() {
      stopCountdown();
      
      if (appState.rateLimit.resetTime > Date.now()) {
        updateCountdownDisplay();
        appState.countdownInterval = setInterval(updateCountdownDisplay, apiConfig.updateInterval);
      }
    }

    function stopCountdown() {
      if (appState.countdownInterval) {
        clearInterval(appState.countdownInterval);
        appState.countdownInterval = null;
      }
    }

    function updateCountdownDisplay() {
      const now = Date.now();
      const timeLeft = Math.max(0, appState.rateLimit.resetTime - now);
      
      if (timeLeft <= 0) {
        stopCountdown();
        appState.rateLimit.remaining = apiConfig.rateLimit.maxRequests;
        appState.rateLimit.resetTime = 0;
        updateRateLimitDisplay();
        return;
      }
      
      const secondsLeft = Math.ceil(timeLeft / 1000);
      nextRequestTimeEl.textContent = `in ${secondsLeft} seconds`;
      
      if (secondsLeft % 5 === 0) {
        localStorage.setItem('rateLimitState', JSON.stringify(appState.rateLimit));
      }
    }

    function updateRateLimitDisplay() {
      const rateLimitInfo = document.getElementById('rate-limit-info');
      
      if (appState.rateLimit.remaining <= 0) {
        rateLimitInfo.textContent = 'Rate limit exceeded';
        if (!appState.countdownInterval) {
          startCountdown();
        }
      } else {
        rateLimitInfo.textContent = `${appState.rateLimit.remaining} request${appState.rateLimit.remaining !== 1 ? 's' : ''} remaining`;
        nextRequestTimeEl.textContent = 'Ready';
      }
    }

    function showNotification(message, isError = false) {
      const existingNotif = document.querySelector('.notification-center');
      if (existingNotif) existingNotif.remove();
      
      const notification = document.createElement('div');
      notification.className = `notification-center ${isError ? 'error' : 'success'}`;
      notification.innerHTML = `
        <div class="notification-content">
          <span class="material-icons">${isError ? 'error' : 'check_circle'}</span>
          <span>${message}</span>
        </div>
      `;
      
      document.body.appendChild(notification);
      
      const bottomNavHeight = document.querySelector('.bottom-nav').offsetHeight;
      const centerY = window.innerHeight / 2 - bottomNavHeight / 2;
      
      notification.style.top = `${centerY}px`;
      notification.style.transform = 'translate(-50%, -50%)';
      
      setTimeout(() => notification.classList.add('show'), 10);
      
      setTimeout(() => {
        notification.classList.remove('show');
        setTimeout(() => notification.remove(), 300);
      }, 3000);
    }

    async function makeApiRequest() {
      try {
        const response = await fetch(apiConfig.baseUrl);
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const data = await response.json();
        
        if (typeof data !== 'object' || data === null) {
          throw new Error('Invalid API response');
        }
        
        return data;
      } catch (error) {
        console.error('API request failed:', error);
        throw error;
      }
    }

    function updateRateLimitState(success) {
      const now = Date.now();
      
      if (success) {
        if (now > appState.rateLimit.resetTime) {
          appState.rateLimit = {
            remaining: apiConfig.rateLimit.maxRequests - 1,
            resetTime: now + apiConfig.rateLimit.timeWindow,
            lastRequest: now
          };
        } else {
          appState.rateLimit.remaining--;
          appState.rateLimit.lastRequest = now;
        }
      } else {
        appState.rateLimit = {
          remaining: 0,
          resetTime: now + apiConfig.rateLimit.cooldownPeriod,
          lastRequest: now
        };
      }
      
      localStorage.setItem('rateLimitState', JSON.stringify(appState.rateLimit));
      updateRateLimitDisplay();
    }

    function handleRateLimitExceeded(data) {
      const cooldownEnd = Date.now() + apiConfig.rateLimit.cooldownPeriod;
      
      appState.rateLimit = {
        remaining: 0,
        resetTime: cooldownEnd,
        lastRequest: Date.now()
      };
      
      localStorage.setItem('rateLimitState', JSON.stringify(appState.rateLimit));
      updateRateLimitDisplay();
      
      showNotification(data.message || 'Rate limit exceeded. Please try again later.', true);
      
      setTimeout(() => {
        appState.rateLimit = {
          remaining: apiConfig.rateLimit.maxRequests,
          resetTime: 0,
          lastRequest: 0
        };
        updateRateLimitDisplay();
      }, apiConfig.rateLimit.cooldownPeriod);
    }

    async function handleRequestError(error) {
      console.error('Request error:', error);
      
      if (appState.retryCount < apiConfig.retry.maxRetries) {
        appState.retryCount++;
        showNotification(`Attempt ${appState.retryCount} of ${apiConfig.retry.maxRetries}. Retrying...`, true);
        
        await new Promise(resolve => setTimeout(resolve, apiConfig.retry.delay));
        return triggerUpdate();
      }
      
      const cooldownEnd = Date.now() + apiConfig.rateLimit.errorCooldown;
      
      appState.rateLimit = {
        remaining: 0,
        resetTime: cooldownEnd,
        lastRequest: Date.now()
      };
      
      localStorage.setItem('rateLimitState', JSON.stringify(appState.rateLimit));
      updateRateLimitDisplay();
      
      showNotification('Service temporarily unavailable. Please try again later.', true);
      appState.retryCount = 0;
      
      setTimeout(() => {
        appState.rateLimit = {
          remaining: apiConfig.rateLimit.maxRequests,
          resetTime: 0,
          lastRequest: 0
        };
        updateRateLimitDisplay();
      }, apiConfig.rateLimit.errorCooldown);
    }

    async function triggerUpdate() {
      const now = Date.now();
      
      if (now < appState.rateLimit.resetTime && appState.rateLimit.remaining <= 0) {
        const timeLeft = Math.ceil((appState.rateLimit.resetTime - now) / 1000);
        showNotification(`Please wait ${timeLeft} seconds before trying again.`, true);
        return;
      }
      
      if (now - appState.rateLimit.lastRequest < 1000) {
        showNotification('Please wait a moment between requests', true);
        return;
      }
      
      refreshBtn.disabled = true;
      refreshBtn.classList.add('loading');
      
      try {
        const data = await makeApiRequest();
        
        if (data.success) {
          showNotification('Scores updated successfully!');
          appState.retryCount = 0;
          updateRateLimitState(true);
          
          refreshBtn.classList.add('success');
          setTimeout(() => refreshBtn.classList.remove('success'), 1000);
        } else if (data.statusCode === 429) {
          handleRateLimitExceeded(data);
        }
      } catch (error) {
        await handleRequestError(error);
      } finally {
        refreshBtn.disabled = false;
        refreshBtn.classList.remove('loading');
      }
    }

    initializeUI();
</script>

</body>
</html>